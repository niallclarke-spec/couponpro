<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CodeTag Admin</title>
  <meta name="robots" content="noindex" />
</head>
<body>
  <script src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"></script>

  <script>
    (function () {
      if (location.search.includes('noext=1')) return;

      const GH_OWNER  = 'niallclarke-spec';
      const GH_REPO   = 'couponpro';
      const GH_BRANCH = 'main';

      function debug(){/* noop in prod */ }

      function sniffTokenFromStorage(){
        try{
          const keys = ['gh_token','decap-cms-user','netlify-cms-user'];
          for (const k of keys){
            const raw = localStorage.getItem(k);
            if (!raw) continue;
            if (k === 'gh_token' && raw) return raw;
            try{
              const obj = JSON.parse(raw);
              if (obj && obj.token) return obj.token;
              if (obj && obj.value && obj.value.token) return obj.value.token;
              if (obj && obj.data && obj.data.token) return obj.data.token;
            }catch(_){}
          }
          for (let i=0;i<localStorage.length;i++){
            const k = localStorage.key(i);
            const v = localStorage.getItem(k);
            try{
              const obj = JSON.parse(v);
              if (obj && obj.token) return obj.token;
              if (obj && obj.value && obj.value.token) return obj.value.token;
              if (obj && obj.data && obj.data.token) return obj.data.token;
            }catch(_){}
          }
        }catch(_){}
        return null;
      }

      async function ghJson(url, token, opts){
        const r = await fetch(url, Object.assign({}, opts, {
          headers: Object.assign({
            'Accept': 'application/vnd.github+json',
            'Authorization': 'token ' + token
          }, (opts && opts.headers) || {})
        }));
        if (!r.ok){
          const t = await r.text();
          throw new Error(r.status + ' ' + r.statusText + ' – ' + t);
        }
        return r.json();
      }

      function b64e(s){
        return btoa(unescape(encodeURIComponent(s)));
      }

      async function regenerateTemplateIndex(onButton){
        try{
          if (onButton){ onButton.disabled = true; onButton.textContent = 'Generating…'; }

          const token = sniffTokenFromStorage();
          if (!token){
            alert('Missing GitHub OAuth token. Please log out/in, then try again.');
            throw new Error('No OAuth token');
          }

          const listUrl = 'https://api.github.com/repos/' + GH_OWNER + '/' + GH_REPO + '/contents/assets/templates?ref=' + GH_BRANCH;
          const entries = await ghJson(listUrl, token);

          const templates = [];
          for (const e of entries){
            if (e.type !== 'dir') continue;
            const slug = e.name;

            const folderUrl = 'https://api.github.com/repos/' + GH_OWNER + '/' + GH_REPO + '/contents/assets/templates/' + slug + '?ref=' + GH_BRANCH;
            const items = await ghJson(folderUrl, token);

            let name = slug;
            const meta = items.find(function(x){ return x.type === 'file' && x.name.toLowerCase() === 'meta.json'; });
            if (meta){
              try{
                const metaText = await (await fetch(meta.download_url)).text();
                const metaJson = JSON.parse(metaText);
                if (metaJson && metaJson.name) name = metaJson.name;
              }catch(_){}
            }

            const pngs = items
              .filter(function(x){ return x.type === 'file' && /\.png$/i.test(x.name); })
              .map(function(x){ return 'assets/templates/' + slug + '/' + x.name; });

            function byName(s){
              for (var i=0;i<pngs.length;i++){ if (pngs[i].toLowerCase().indexOf(s) !== -1) return pngs[i]; }
              return null;
            }

            var square = byName('square') || byName('sq') || (pngs[0] || '');
            var story  = byName('story')  || byName('st') || (pngs[1] || pngs[0] || '');

            templates.push({
              slug: slug,
              name: name,
              square: square,
              story: story,
              meta: 'assets/templates/' + slug + '/meta.json'
            });
          }

          const manifest = { templates: templates };

          var sha;
          try{
            const head = await ghJson(
              'https://api.github.com/repos/' + GH_OWNER + '/' + GH_REPO + '/contents/assets/templates/index.json?ref=' + GH_BRANCH,
              token
            );
            sha = head && head.sha;
          }catch(_){}

          const putUrl = 'https://api.github.com/repos/' + GH_OWNER + '/' + GH_REPO + '/contents/assets/templates/index.json';
          const body = {
            message: 'chore: regenerate templates index.json',
            branch: GH_BRANCH,
            content: b64e(JSON.stringify(manifest, null, 2))
          };
          if (sha) body.sha = sha;

          const resp = await fetch(putUrl, {
            method: 'PUT',
            headers: {
              'Accept': 'application/vnd.github+json',
              'Authorization': 'token ' + token,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
          });
          if (!resp.ok){
            const t = await resp.text();
            throw new Error(resp.status + ' ' + resp.statusText + ' – ' + t);
          }

          if (onButton){
            onButton.textContent = 'Index updated ✓';
            setTimeout(function(){ onButton.textContent = 'Regenerate Template Index'; onButton.disabled = false; }, 1500);
          }
        }catch(err){
          console.error('[Regenerate index] failed:', err);
          alert('Failed to regenerate index.json — open DevTools and check the console.');
          if (onButton){ onButton.textContent = 'Regenerate Template Index'; onButton.disabled = false; }
        }
      }

      function mountToolbarButton(){
        var tries = 0;
        (function poll(){
          tries++;
          var root = document.querySelector('#nc-root');
          if (!root){ if (tries < 60) return setTimeout(poll, 500); else return; }
          var bar = root.querySelector('header[role="toolbar"], [class*="Toolbar"]');
          if (!bar){ if (tries < 60) return setTimeout(poll, 500); else return; }
          if (bar.dataset.ctIndexBtn) return;
          bar.dataset.ctIndexBtn = '1';

          var btn = document.createElement('button');
          btn.style.marginLeft = 'auto';
          btn.style.padding = '8px 12px';
          btn.style.borderRadius = '10px';
          btn.style.border = '1px solid #2b313b';
          btn.style.background = 'linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02))';
          btn.style.color = '#e9eef5';
          btn.textContent = 'Regenerate Template Index';
          btn.onclick = function(){ regenerateTemplateIndex(btn); };
          bar.appendChild(btn);
        })();
      }

      function installOnceCMSReady(){
        var tries = 0;
        (function waitCMS(){
          tries++;
          if (window.CMS && typeof window.CMS.registerEventListener === 'function'){
            try{
              window.CMS.registerEventListener({
                name: 'entryPublished',
                handler: function(){ regenerateTemplateIndex().catch(function(e){ console.error(e); }); }
              });
            }catch(_){}
            mountToolbarButton();
          } else {
            if (tries < 60) setTimeout(waitCMS, 500);
          }
        })();
      }

      installOnceCMSReady();
    })();
  </script>
</body>
</html>